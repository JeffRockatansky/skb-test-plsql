- [Введение](#введение)
- [ОБЯЗАТЕЛЬНАЯ ЧАСТЬ](#обязательная-часть)
	- [1. `[PL/SQL]`: Функции и процедуры](#1-plsql-функции-и-процедуры)
		- [1. Что есть что, и в чем различия?](#1-что-есть-что-и-в-чем-различия)
		- [2. Сколько значений могут возвращать функции и процедуры?](#2-сколько-значений-могут-возвращать-функции-и-процедуры)
		- [3. Привести по примеру описания функции и процедуры на PL/SQL, а также привести пример их вызова.](#3-привести-по-примеру-описания-функции-и-процедуры-на-plsql-а-также-привести-пример-их-вызова)
	- [2. `[C# | Java | PL/SQL]`: Сортировка методом "Пузырька".](#2-c--java--plsql-сортировка-методом-пузырька)
		- [1. Описать своими словами в чем он заключается.](#1-описать-своими-словами-в-чем-он-заключается)
		- [2. Привести пример реализации.](#2-привести-пример-реализации)
	- [3. `[PL/SQL]`: Имеется две таблицы, А и B, заполненные консистентными данными.](#3-plsql-имеется-две-таблицы-а-и-b-заполненные-консистентными-данными)
		- [1. Какими способами можно вывести:](#1-какими-способами-можно-вывести)
	- [4. `[PL/SQL]`: Необходимо переписать следующий фрагмент кода , чтобы избавиться от ненужных вложенных ~~циклов~~ **условных операторов**:](#4-plsql-необходимо-переписать-следующий-фрагмент-кода--чтобы-избавиться-от-ненужных-вложенных-sцикловs-условных-операторов)
	- [5. `[PL/SQL]`: Вывести в результате запроса числа от 1 до 1000.](#5-plsql-вывести-в-результате-запроса-числа-от-1-до-1000)
	- [6. `[PLSQL]`: Сгенерировать произвольным образом содержимое таблицы C, на основе данных таблицы А и B](#6-plsql-сгенерировать-произвольным-образом-содержимое-таблицы-c-на-основе-данных-таблицы-а-и-b)
	- [7. `[PL/SQL]`: Сформировать простенький XML и распарсить его.](#7-plsql-сформировать-простенький-xml-и-распарсить-его)
- [ДОПОЛНИТЕЛЬНАЯ ЧАСТЬ](#дополнительная-часть)
	- [8. `[PL/SQL]`: Загрузить содержимое файла Excel в таблицу.](#8-plsql-загрузить-содержимое-файла-excel-в-таблицу)
	- [9. `[PL/SQL]`: Объяснить в каком порядке будут выбираться данные из таблиц, какие таблицы будут задействованы в первую очередь, какие потом.](#9-plsql-объяснить-в-каком-порядке-будут-выбираться-данные-из-таблиц-какие-таблицы-будут-задействованы-в-первую-очередь-какие-потом)
	- [10. `[PLSQL]`: Написать PL/SQL блок, который добавляет запись в таблицу C.](#10-plsql-написать-plsql-блок-который-добавляет-запись-в-таблицу-c)
	- [11. `[PL/SQL]`: Написать запрос, выводящий остаток на счете после совершения каждой проводки.](#11-plsql-написать-запрос-выводящий-остаток-на-счете-после-совершения-каждой-проводки)
	- [12. `[PL/SQL]`: Создать таблицу E, в которой имеются некие данные и колонка с временем (датой) записи в таблицу.](#12-plsql-создать-таблицу-e-в-которой-имеются-некие-данные-и-колонка-с-временем-датой-записи-в-таблицу)
	- [13. `[Теория вероятностей]`: Задача о роддомах.](#13-теория-вероятностей-задача-о-роддомах)

# Введение
В скобках `[ <> ]` указаны предпочтительные языки программирования, на которых хотелось бы видеть результат (можно на одном из указанных).

Все задания указаны в порядке возрастания сложности.

Обязательная часть выполняется по максимуму (будет оцениваться не сколько количество, сколько качество выполнения заданий).

Дополнительная часть выполняется по желанию.

# ОБЯЗАТЕЛЬНАЯ ЧАСТЬ
## 1. `[PL/SQL]`: Функции и процедуры
### 1. Что есть что, и в чем различия?
* Функции и процедуры - поименованные блоки кода, которые можно переиспользовать, вызывая их по имени для избегания повторений.
* Функции и процедуры могут принимать на вход параметры, указанные в произвольном количестве при их определении.
* Различия:

| Параметры сравнения  | Процедуры                                                               | Функции                                                                                                                                                          |
| -------------------- | ----------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Определение          | Не имеет ключевого слова `return <type>` в определении                  | обязательно указывается ключевое слово `return <type>`                                                                                                           |
| Возврат значений     | могут возвращать или не возвращать значения                             | обязательно возвращают значение                                                                                                                                  |
| Применение           | преимущественно для работы с объектами БД с помощью DML-операций        | для создания и обработки данных, имплементации алгоритмов и логических операций                                                                                  |
| Использование в коде | Только в `PL/SQL`, нельзя в запросах. Можно вызвать просто по названию. | В `SQL` и `PL/SQL`, в т.ч. в запросах. Обязательно вызывается в контексте, где возвращаемое значение как-то используется (наприммер, записывается в переменнукю) |

### 2. Сколько значений могут возвращать функции и процедуры?
* Процедуры могут возвращать значения, указанные в списке аргументов с применением ключевого слова `out`.
* Функции в дополнение к этому могут возвращать одно значение с помощью ключевого слова `return`.
* Кроме того, если определить возвращаемый тип функции как `pipelined`, то из функции можно возвращать табличные типы, что в результате снимает ограничение на количество возвращаемых значений.

### 3. Привести по примеру описания функции и процедуры на PL/SQL, а также привести пример их вызова.
* [x] [**1.3.sql**](./code/SQL/1.3.sql)

## 2. `[C# | Java | PL/SQL]`: Сортировка методом "Пузырька".
### 1. Описать своими словами в чем он заключается.
* Алгоритм последовательно со сдавигом на одну позицию вперёд проходит по ряду значений от младших позиций к старшим, сравнивая значения на двух соседних позициях. Если из двух сравниваемых значений меньшее находится дальше по ряду, чем большее, то они меняются местами. Это происходит `n*(n-1)` раз, где `n` - число значений в ряду.
* Возможны некоторые оптимизации, например можно не проверять те значения, которые уже отсортированы.
* Технически обычно выполняется с использованием двух вложенных циклов `for` и одной проверки условия `if`.

### 2. Привести пример реализации.
* [x] [**2.2.sql**](./code/SQL/2.2.sql)

## 3. `[PL/SQL]`: Имеется две таблицы, А и B, заполненные консистентными данными.
### 1. Какими способами можно вывести:
1. записи из таблицы А, которых нет в таблице B;
2. записи, которые имеются одновременно и в таблице А, и в таблице B;
3. записи, которые имеются либо в таблице А, либо в таблице B;
4. уникальные записи, которые имеются либо в таблице А, либо в таблице B.

* [x] [**3.1.sql**](code/SQL/3.1.sql)

## 4. `[PL/SQL]`: Необходимо переписать следующий фрагмент кода , чтобы избавиться от ненужных вложенных ~~циклов~~ **условных операторов**:

```sql
-- В виде блока PL/SQL кода
IF salary < 10000
	THEN bonus := 2000;
ELSIF salary < 20000
	THEN bonus := 1500;
ELSIF salary < 40000
	THEN bonus := 1000;
ELSE bonus := 500;
END IF;

-- В виде запроса
select
	case
		when salary < 10000 THEN 2000
		when salary < 20000 THEN 1500
		when salary < 40000 THEN 1000
		ELSE 500
	end bonus
from
	emp_salary_calc;
```

## 5. `[PL/SQL]`: Вывести в результате запроса числа от 1 до 1000.
* [x] [**5.sql**](./code/SQL/5.sql)

## 6. `[PLSQL]`: Сгенерировать произвольным образом содержимое таблицы C, на основе данных таблицы А и B

**Таблица А:**
|        |                |
| ------ | -------------- |
| EMPFIO | ФИО сотрудника |

**Таблица B:**
|      |                            |
| ---- | -------------------------- |
| OWNM | Наименование подразделения |

**Таблица C:**
|        |                            |
| ------ | -------------------------- |
| OWNM   | Наименование подразделения |
| EMPFIO | ФИО сотрудника             |

* [x] [**6.sql**](./code/SQL/6.sql)

## 7. `[PL/SQL]`: Сформировать простенький XML и распарсить его. 
* Например: `<SKB><S>Самый</S><K>Клёвый</K><B>Банк</B></SKB>`

* [ ] [7.sql](./code/SQL/7.sql)

# ДОПОЛНИТЕЛЬНАЯ ЧАСТЬ
*повышенная сложность, выполняется по желанию*

---

## 8. `[PL/SQL]`: Загрузить содержимое файла Excel в таблицу.

Excel:

| Имя колонки | Описание            | Возможны пустые значения |
| ----------- | ------------------- | ------------------------ |
| FIO         | ФИО клиента         |                          |
| ACCN        | Номер счета         |                          |
| ACNC        | ИД счета            |                          |
| COMM        | Комментарий         | Да                       |
| DTST        | Дата открытия счета |                          |
| DTEX        | Дата закрытия счета | Да                       |

Таблица:

| Имя колонки | Описание            |
| ----------- | ------------------- |
| ACNC        | ИД счета            |
| ACCN        | Номер счета         |
| DTEX        | Дата закрытия счета |

## 9. `[PL/SQL]`: Объяснить в каком порядке будут выбираться данные из таблиц, какие таблицы будут задействованы в первую очередь, какие потом.
* Таблицы и данные использовать из предыдущего задания.
	* `select * from A, B, C where a.empfio=c.empfio and b.ownm=c.ownm`
	* `select * from B, A, C where a.empfio=c.empfio and b.ownm=c.ownm`
* Написать запросы, выбирающие данные из таблиц в обратном порядке их использования в указанных двух запросах. Дать комментарий по предоставленному решению. Т.е.:
	* `C->B->A`
	* `C->A->B`

## 10. `[PLSQL]`: Написать PL/SQL блок, который добавляет запись в таблицу C.
* Значения полей должны браться из переменных.
* Перед добавлением записи проверить, нет ли уже такой записи в таблице.
* Если запись есть – генерировать пользовательское исключение.
* В обработчике исключения вывести в консоль (output) ошибку.

## 11. `[PL/SQL]`: Написать запрос, выводящий остаток на счете после совершения каждой проводки.
* Т.е. надо к стартовой сумме прибавить/вычесть сумму первой проводки, к полученной сумме добавить/вычесть сумму второй и т.д. Иными словами, нужно накапливать результат.

```sql
create table D (
	id number,
	account varchar2(20), 
	value number 
);

insert into D values (1,'01',100);
insert into D values (2,'02',200);
insert into D values (3,'01',-100);
insert into D values (4,'01',200);
insert into D values (5,'02',100);
insert into D values (6,'01',-100);
insert into D values (7,'01',100);
insert into D values (8, '02',10);
insert into D values (9, '02',20);
insert into D values (10,'01',-10);
insert into D values (11,'01',-20);
insert into D values (12,'03',10);
insert into D values (13,'03',-10);
insert into D values (14,'01',10);
```

## 12. `[PL/SQL]`: Создать таблицу E, в которой имеются некие данные и колонка с временем (датой) записи в таблицу.
* Заполнить таблицу произвольными данными (20 строк).
* Необходимо написать запрос, который бы вывел все записи в порядке добавления.
* А также последней колонкой рассчитать сколько времени прошло между вставками этих строк.

## 13. `[Теория вероятностей]`: Задача о роддомах.
* Представьте, что вы живете в городе, где есть два роддома – один большой, другой маленький. В каком роддоме более высокая вероятность рождения преимущественно мальчиков? В маленьком или большом? Ответ необходимо обосновать.